# ChatSim 开发文档

## 项目介绍

**ChatSim**（校园恋爱模拟聊天系统）是一个使用大语言模型（LLM）驱动的聊天程序。它模拟校园恋爱场景中的对话，由 AI 扮演女主角，与玩家进行互动对话。项目的目标是在互动过程中模拟真实的情感变化和情节发展，让用户体验沉浸式的校园恋爱对话。ChatSim 提供了图形用户界面，方便用户以聊天形式与 AI 进行多轮对话，并通过情绪和状态系统跟踪女主角的心情和故事进展。

## 项目功能介绍

ChatSim 具备以下主要功能：

* **基于大语言模型的对话模拟**：利用 OpenAI 接口生成对话内容，AI 扮演女主角角色，与用户进行自然语言聊天。
* **多轮对话 & 流式回复**：支持连续多轮的对话上下文，AI 回复采用流式输出，逐字逐句地呈现，模拟实时打字的效果。
* **情绪与状态系统**：内置情绪（开心、生气、害羞等）和状态（放空、紧张、期待等）概念，AI 会根据上下文和模型输出更新自己的情绪和状态，并显示在界面上。
* **历史记录保存与加载**：对每次对话进行存档，支持将聊天历史和角色状态保存到本地文件（JSON），下次启动时可加载，从而继续上次的聊天进度。
* **场景式旁白生成**：预设了剧情场景（如初遇、图书馆、婚礼等）及好感度触发阈值。当好感度达到条件时，会进入下一个场景。对于每个场景，系统可以插入预设的旁白或通过 AI **自动生成**场景描述，营造生动的叙事氛围。
* **图形界面交互（GUI）**：基于 Tkinter 实现本地图形界面，提供聊天窗口、输入框、发送按钮、对话气泡显示以及状态栏等，用户可直接在桌面应用中与 AI 交互。

## 技术栈说明

本项目主要使用 **Python 3** 进行开发，结合了一系列库和技术来实现上述功能：

* **大语言模型接口**：使用 OpenAI 提供的聊天模型接口生成内容。通过`openai`官方库调用聊天 completions 接口，实现 AI 对话。模型调用支持自定义`BASE_URL`，可配置代理或第三方模型服务。开发者需提供有效的 API Key（详见“构建与运行”部分）。
* **图形界面**：使用标准库 Tkinter 实现本地 GUI。包含主窗口、对话显示区域、滚动条、文本输入框和按钮等组件，提供直观的聊天窗口界面。界面采用多线程技术避免卡顿，UI 操作和耗时的模型请求在不同线程中执行。
* **多线程与流式输出**：使用 Python 的`threading`模块处理耗时的 AI 响应请求，使请求在后台线程执行，防止阻塞 Tkinter 主循环。结合 Tkinter 的`after()`方法，实现将AI回复逐字逐句地流式添加到聊天窗口，营造实时对话的效果。这种流式输出通过在后台获取完整回复后，按语义切分成块，然后逐字符追加到对话气泡实现。
* **架构设计**：采用 **MVC 分层架构** 将逻辑解耦。*Model* 层负责数据和状态（如游戏状态、历史记录、场景配置、API 接口封装等）；*Controller* 层处理业务逻辑（如接收用户输入、调用模型、更新状态）；*View* 层即 GUI 界面，负责显示和用户交互。这种分层设计提高了代码模块化和可维护性，各模块职责清晰。
* **数据存储**：使用 JSON 文件保存聊天历史和游戏状态。在 `data/` 目录下，`history.json`保存对话消息列表，`state.json`保存当前场景、好感度、情绪状态等。通过 Model 层提供的接口加载和保存，保证每次运行状态的延续。
* **其他依赖**：项目使用标准库模块如`json`、`os`、`time`、`queue`等处理序列化、文件和时间逻辑；使用`typing`提供类型注解提高代码可读性；颜色和界面布局使用 Tkinter 内置功能，无额外第三方 GUI 库。开发和调试过程中，可开启**DEBUG模式**输出详细日志（在`config.py`中切换）。

## 项目结构

项目采用模块化结构，主要目录和文件如下：

* **`main.py`** – 程序入口，启动 ChatSim 应用。
* **`config.py`** – 全局配置文件，定义 API Key、接口 URL、初始游戏状态和参数等。
* **`gui/`** – 图形界面模块，包含 UI 界面相关的代码，例如主窗口`window.py`、聊天显示`chat_frame.py`、输入框`input_frame.py`、对话气泡`chat_bubble.py`、状态控制面板`control_panel.py`以及初始化逻辑`window_init.py`等。
* **`controller/`** – 控制器模块，处理用户输入与模型响应的业务逻辑，例如聊天控制`chat_controller.py`、流式响应处理`stream_handler.py`，以及辅助函数`helpers.py`、流式工具`stream_utils.py`等。
* **`model/`** – 模型层模块，负责数据管理和AI接口，包括历史记录管理`history.py`、游戏状态管理`game_state/`（内含游戏状态类及加载保存逻辑）、聊天模型调用`chatbot_api.py`、后备回复策略`chat_fallback.py`、场景配置`scene.py`和场景旁白生成`scene_generator.py`等。
* **`data/`** – 数据存储目录，默认包含历史记录文件**history.json**和状态文件**state.json**，用于持久化对话和游戏进度。
* **`assets/`** – 资源文件夹（如角色头像图片等）。*（当前版本中该目录为空或未使用，预留用于扩充项目资源）*。
* **`utils/`** – 工具模块，提供调试日志等辅助功能（如`debug_tools.py`）。在 DEBUG 模式下输出调试信息，帮助开发和排查问题。
* **`README.md`** – 项目说明文档，包含使用介绍、安装运行方法等。

*(注：以下文档内包含各模块主要源码片段。点击各部分标题旁的“跳转到源码”可查看对应源码片段。)*

## 项目代码介绍

下面按模块详细介绍项目的主要代码结构、关键类和函数功能。

### 主程序与配置 {#main-config}

#### main.py（[跳转到源码](#source-main-py)）

**作用**：程序主入口，负责初始化应用并启动 GUI 主循环。

* **`main()`** – 创建主窗口 `Window` 实例并调用其 `mainloop()` 方法，进入 Tkinter 的事件循环。当直接运行此文件时（`__name__ == "__main__"`），调用 `main()` 函数启动程序。

该文件非常简洁，其主要工作是加载 GUI 界面并开始应用运行。所有界面元素和逻辑由 `gui.window.Window` 类实现。

#### config.py（[跳转到源码](#source-config-py)）

**作用**：全局配置和常量定义，包含 API 接口参数、文件路径、初始游戏设置等。

* **API 接口配置**：定义 OpenAI 接口所需的 `API_KEY`、`ENDPOINT_ID`、`BASE_URL` 等参数。默认情况下，`API_KEY`会从环境变量读取（键名`ARK_API_KEY`），如未设置则使用文件中提供的默认值；`BASE_URL` 默认为 OpenAI 兼容接口的地址，可根据需要替换为代理服务地址。\*\*请注意：\*\*为安全起见，首次使用前应将默认的密钥替换为您自己的 API Key。
* **路径配置**：指定历史记录和状态保存文件的位置，如`HISTORY_PATH = "data/history.json"`，`STATE_PATH = "data/state.json"`。
* **游戏场景配置**：通过字典 `SCENES` 定义游戏中的剧情场景及转换逻辑。每个场景包含触发好感度阈值 (`trigger`)、后续场景列表 (`next`)、预设旁白 (`preset`) 以及是否自动生成旁白 (`autogen`) 等属性。例如：场景“intro”触发阈值10，好感度达到时进入“library”场景；“wedding”场景为最终场景，有预设旁白文本。
* **情绪与状态列表**：预定义女主角可能的情绪 `EMOTIONS` 和状态 `STATUSES` 列表，各包含若干固定选项（均为两个汉字的描述）。模型应从这些选项中选取最符合上下文的情绪和状态，用于更新 UI 状态栏。
* **调试模式**：布尔值 `DEBUG_MODE` 控制调试输出。开启时（True）将在控制台打印调试信息，以`[DEBUG]`前缀标识。

### 模型模块 {#model-module}

模型模块包括数据存储、游戏状态管理，以及与 AI 接口交互等部分。

#### model/history.py（[跳转到源码](#source-history-py)）

**作用**：提供聊天历史记录的读写接口。

* **`load_history()`** – 从历史文件加载聊天记录列表。如果文件不存在或为空，返回空列表；如有内容则反序列化 JSON 返回消息列表（每条记录包含角色和内容）。
* **`save_history(history)`** – 将当前聊天历史保存到文件。使用JSON格式存储，包含缩进便于阅读，`ensure_ascii=False`以保存中文字符。保存成功或失败均会打印调试信息提示。
* **`reset_history()`** – 重置历史记录文件。实质上是将文件内容清空为`[]`（空的JSON数组），并打印调试日志说明历史记录已清空。

这些函数由控制器调用：加载历史在应用初始化时完成，保存历史在每次 AI 回复后触发，重置历史用于“重新开始”功能清除进度。

#### model/game\_state（GameState 类）（[跳转到源码](#source-gamestate)）

**作用**：管理游戏进行过程中的状态信息，包括当前场景、好感度以及女主角的情绪状态等，并提供场景跳转判断。

`GameState`类定义在`model/game_state/__init__.py`中，由多个部分组成：

* **属性**：初始化时设定默认状态：

  * `current_scene` 当前场景（初始为 `"intro"`开场白场景）。
  * `favor` 好感度（初始值0）。
  * `triggered` 已触发场景集合（初始为空，用于避免重复触发相同场景）。
  * `is_finished` 是否已结束（初始 False，用于标记是否到达最终场景）。
  * `emotion` 当前情绪（初始为“平静”）和 `status` 当前状态（初始为“放空”），从配置列表中选用默认值。
* **方法**：

  * `to_dict()` – 将当前状态转换为字典，用于序列化保存。包括场景名、好感度、已触发场景列表（集合转列表）、结束标志、情绪和状态。
  * `save()` – 保存当前状态到文件。内部调用下文介绍的`save_state()`函数执行实际文件写入。
  * `reset()` – 重置状态并清除存档。调用`reset_state_file()`清空状态保存文件，然后重新调用自身`__init__()`将所有属性恢复初始值。
  * `check_scene_transition()` – 检查并执行场景跳转逻辑。内部调用`transition.py`中的函数`check_scene_transition(self)`来根据当前好感度决定是否进入新场景。
  * `load(cls)` *(类方法)* – 从本地加载保存的游戏状态，返回一个 `GameState` 实例。调用`loader.py`中的`load_state(cls)`函数实现。

**状态加载与保存**：对应在`model/game_state/loader.py`中定义了文件读写的辅助函数：

* `load_state(GameStateClass)` – 从状态文件加载数据，生成并返回 `GameStateClass` 实例。如果文件不存在或为空，则返回一个新的默认状态对象；如果有内容则解析 JSON，将各字段赋值给对象对应属性。发生任何异常则输出调试信息并返回默认对象。
* `save_state(state_obj)` – 将传入的状态对象序列化为 JSON 并写入状态文件。保存时使用`ensure_ascii=False`保证中文不被转码，`indent=2`美化格式。操作成功或异常都会打印调试日志。
* `reset_state_file()` – 清空状态文件内容，用于`GameState.reset()`时重置存档。

**场景跳转逻辑**：在`model/game_state/transition.py`中实现：

* `check_scene_transition(state)` – 检查当前状态中的好感度是否达到当前场景的跳转条件。获取当前场景ID和对应阈值；如果好感度达到阈值且该场景未被触发过，则将当前场景标记为已触发，然后获取下一个场景ID。如果不存在下一个场景（即当前为最终场景）则直接返回；否则，将游戏状态的`current_scene`更新为下一场景。随后根据新场景是否需要自动生成旁白决定日志输出（实际的旁白添加逻辑在控制器中处理）。

综上，GameState 管理着游戏进程相关的所有数据，并通过上述方法支持状态持久化和场景推进。控制器会频繁使用 GameState：启动时调用`GameState.load()`载入状态，生成回复后更新情绪/状态/好感度，检查场景转换，在程序退出或回复结束时调用`state.save()`保存。

#### model/chatbot\_api.py（[跳转到源码](#source-chatbot-api-py)）

**作用**：封装与聊天 AI 模型交互的接口，负责向 OpenAI（或兼容服务）发送对话请求并获取回复。

* **初始化**：创建 OpenAI API 客户端对象 `client`。使用 `OpenAI(api_key=..., base_url=...)` 进行初始化，其中 `api_key` 和 `base_url` 从 `config.py` 中读取。这样可灵活替换 API Key 或使用代理服务。

* **`chat_stream(messages: list) -> dict`** – 主对话接口，流式获取 AI 回复。传入参数为对话消息列表，其中每个消息是一个字典包含`role`和`content`。该方法执行以下流程：

  1. 在用户提供的对话消息列表前插入一个**系统指令**消息，用于引导模型输出特定格式。该系统消息指示模型以**女主角**身份回复，并**严格按照 JSON 格式**输出包含`reply`（回复内容）, `emotion`（情绪）, `status`（状态）, `favor`（好感度变化）这四个字段。它明确列出可能的情绪和状态选项以及 JSON 输出要求，确保模型返回结构化结果。
  2. 将最终的消息列表（系统指令 + 最近最多20条对话）发送给 OpenAI 的 ChatCompletion 接口，请求流式 (`stream=True`) 响应。模型将逐步返回内容块，本函数开启一个后台线程来持续接收这些流数据。
  3. 在后台接收线程中，对于收到的每个数据块，提取其中的新内容增量并放入线程安全的队列 `result_queue` 中。同时使用 `finished` 事件标志来指示回复接收完毕或发生异常。
  4. 主线程等待队列内容，逐块拼接组成完整的回复字符串 `full_reply`。如果等待超过15秒仍未收到新内容，则认为超时并跳出循环，准备使用后备回复。
  5. 尝试将完整回复字符串解释为 JSON 对象。如果解析成功且包含预期的四个字段，则将该 JSON 对象作为结果返回；否则，认为模型未按要求格式化输出，进入**fallback**流程。
  6. **Fallback 策略**：如果模型输出无法解析或超时，函数返回一个默认结构的字典，包括:

     * `"reply"`: 使用 `full_reply` 中的原始文本（去除首尾空白）。如果模型完全没有返回内容，则调用 `get_default_reply()` 获取一条预设的默认回复。
     * `"emotion"`: 默认为“平静”，表示情绪未知或中性。
     * `"status"`: 默认为“放空”。
     * `"favor"`: 默认为0（无好感度变化）。

  整个过程中，会打印若干调试信息，如调用开始、异常情况、JSON解析失败等。

* **`chat_once(messages: list) -> str`** – 单轮对话接口，用于生成一条简短的场景旁白。它不采用流式，而是一次性得到模型完整回复。实现上直接使用`client.chat.completions.create(..., stream=False)`发送消息列表并获取结果。在本项目中，这个方法主要用于`scene_generator.py`中生成场景介绍语。若调用失败或异常，则返回`get_default_reply()`提供的默认句子。

通过`chat_stream`和`chat_once`两个函数，项目分别实现了**对话内容**和**场景旁白**的AI生成。ChatController 在需要时选择调用相应接口获取结果。值得注意的是，系统通过**提示词工程**引导模型返回包含情绪和状态的 JSON，这使后续处理逻辑能够轻松解析并更新 UI 上的状态显示。

#### model/chat\_fallback.py（[跳转到源码](#source-chat-fallback-py)）

**作用**：提供当 AI 模型无响应或输出不符合要求时的**兜底回复**及旁白引导模板。

* **`get_default_reply() -> str`** – 返回一条预设的默认回复文本。当前实现为：“……（她没回应你，好像有点冷淡）”，模拟女主角未作回应、有些冷淡的情况。在模型长时间没有返回时用于填充，避免对话中断。
* **`build_scene_prompt(scene_name: str) -> str`** – 构造用于旁白生成的提示语模板。给定场景名称，返回一段指令，要求 AI 基于该场景生成一句简短的场景描述（包括时间、地点、天气等）。输出示例如“傍晚，教学楼门口，天空飘着细雨。”。*(目前项目中未直接使用此函数，旁白生成采用了`scene_generator.py`中的自定义提示逻辑。该函数可能是备用方案或早期版本保留)*。

#### model/scene.py（[跳转到源码](#source-scene-py)）

**作用**：提供对**场景配置**的访问和判断函数。利用`config.py`中定义的 `SCENES` 配置来获取场景相关信息。

* **`get_prompt(scene_id: str) -> str`** – 获取指定场景预设的旁白文本。如果 `SCENES` 中存在该场景且定义了`preset`字段，则返回预设的旁白字符串；否则返回空字符串。此函数用于在游戏开始无历史记录时插入初始旁白，以及在最终场景（如“wedding”）触发时展示固定结局旁白。
* **`is_autogen(scene_id: str) -> bool`** – 判断某场景是否启用**自动生成旁白**。根据场景配置的`autogen`布尔值返回结果，默认为False。若为True，表示进入该场景时应通过模型自动生成一段旁白而非使用预设文本。
* **`get_trigger_threshold(scene_id: str) -> int`** – 获取场景的好感度触发阈值。返回 `SCENES[scene_id]["trigger"]` 的值，如未定义则返回0。
* **`get_next_scene(scene_id: str) -> str`** – 获取场景的后续场景ID。如果配置中存在`next`列表，返回第一个场景ID；如无后续则返回空字符串。
* **`should_enter_scene(current_scene: str, favor: int) -> bool`** – 判定当前好感度是否满足进入下一个场景条件。内部通过`get_trigger_threshold`获取阈值并比较`favor`，满足则返回True。*(当前项目中未直接使用此函数，场景进入逻辑主要由GameState.check\_scene\_transition处理；该函数可能作为辅助或备用方案)*。

#### model/scene\_generator.py（[跳转到源码](#source-scene-generator-py)）

**作用**：调用模型为新场景生成一条简短的**旁白提示语**。当加载了历史记录时，为避免直接使用预设旁白，项目通过此模块动态生成符合上下文的场景描述。

* **`generate_scene_intro(current_scene: str, emotion: str, status: str, history: list) -> str`** – 根据当前场景和上下文，生成一句新的场景描述。实现步骤：

  1. 构造系统提示（prompt）：以当前场景名、女主当前情绪、状态以及玩家最近说的话为要素，要求模型**扮演旁白生成器**，输出一条简洁的场景描写（10\~25个字）。提示示例见代码，它列出了场景、情绪、状态和最近玩家发言，并指示模型“直接返回一句中文短句，不加注释”。
  2. 将该系统提示封装为消息列表后，调用前述的`chat_once(messages)`接口请求模型输出。
  3. 获取模型返回结果字符串，将其首尾去空白后作为场景提示返回。如果模型未返回内容或调用失败，会由`chat_once`内部返回默认回复，此情况下仍会有合理的默认值保证不中断。

  调用成功时，会打印调试信息显示生成的场景提示。

* **`get_last_user_input(history: list) -> str`** – 工具函数，获取历史记录中最近一条用户发言内容。遍历传入的对话历史列表，返回最后出现的`role`为`"user"`的消息文本；如果没有找到用户消息，则返回“（无）”。

该模块综合利用当前状态和历史上下文来生成更贴合剧情的旁白。例如，如果用户上一次提到了某个话题，生成的场景提示可能会考虑这一点，增强对话的连续性和沉浸感。在程序启动且有历史记录的情况下，ChatSim 会调用此函数生成场景描述作为开场白插入（详见后文 GUI 初始化部分）。

### 控制器模块 {#controller-module}

控制器模块负责**连接模型与视图**，处理用户输入，调用模型生成回复，并更新游戏状态/界面。

#### controller/chat\_controller.py（[跳转到源码](#source-chat-controller-py)）

**作用**：核心聊天控制器，管理对话流程、状态更新和历史记录。

* **初始化** (`__init__`) – 接受聊天窗口 `chat_frame` 和状态更新回调 `update_status_callback` 等参数，创建 ChatController 实例。主要完成：

  * 将传入的 `chat_frame` 保持引用，便于在控制器中直接操作界面（如添加消息气泡）。
  * 保存状态更新回调函数（通常为主窗口的状态栏更新方法），以便在好感度或情绪变化后调用刷新UI。
  * 加载游戏状态和历史记录：调用 `GameState.load()` 从文件初始化当前状态 `self.state`；调用 `load_history()` 获取历史消息列表 `self.history`。这样控制器一启动便拥有了当前对话的上下文数据。
  * 设置内部标记 `_first_prompt_shown = False`，用于跟踪是否已经显示过初始提示语（这个变量在旧版本用于自动显示开场白，现保留以备扩展）。
* **`push_system(text: str)`** – 向聊天窗口插入一条**系统消息**（灰色气泡）。此方法用于添加旁白提示等非用户/AI的消息：

  * 通过 `chat_frame.after(0, ...)` 确保在主线程安全地调用界面方法，在聊天窗口中添加`role="system"`的消息气泡，其内容为给定的文本。
  * 同时，将该消息以`{"role": "system", "content": text}`的形式追加到历史记录列表 `self.history` 中，确保这条旁白也纳入会话上下文。
* **`on_user_input(text: str)`** – 处理用户输入事件。每当用户通过输入框发送消息，主窗口会调用此方法，将文本传递给控制器。

  * 首先打印调试信息，记录玩家输入的内容。
  * 将用户消息添加到界面：使用 `chat_frame.after(0, ...)` 异步地在聊天窗口添加`role="user"`的气泡显示文本。这样用户输入会立即出现在对话框中。
  * 将该用户消息（role为"user"）附加到 `self.history` 列表，以更新对话历史。
  * 最后，启动一个后台线程来处理 AI 的回复。线程目标函数指定为 `handle_stream_response`（控制器下的流响应处理函数），并通过`args`参数传递当前 `chat_frame`、`state`（游戏状态对象）、`history` 列表以及状态更新回调函数。将线程设置为守护线程 `daemon=True` 以便主程序退出时自动结束线程。启动该线程后，控制器的工作线程会并行执行 AI 响应逻辑，而不会阻塞主线程的 UI 更新。

ChatController 简化了主窗口对用户输入的处理流程：一旦用户发送消息，这个控制器负责更新界面、记录历史并异步获取 AI 回复。在AI回复过程中，控制器的状态（情绪、状态、好感度）会由模型线程更新，完成后通过回调刷新UI状态栏。

#### controller/stream\_handler.py（[跳转到源码](#source-stream-handler-py)）

**作用**：处理**AI回复的生成和流式输出**。由 ChatController 在线程中调用，负责与模型交互并将结果逐步更新到界面。

* **`handle_stream_response(chat_frame, state, history, update_status_callback=None)`** – 核心函数，在新线程中执行。参数包括聊天窗口实例、当前游戏状态对象、历史记录列表，以及可选的状态更新回调。

  1. **准备对话上下文**：构建带有情绪和状态说明的系统消息，将其与传入的 `history` 列表组合成新的消息列表。其中 `emotion_prompt` 系统消息内容形如：“当前情绪：{state.emotion}，状态：{state.status}”。这使模型在生成回复时能了解女主角此刻的心情和状态，以产出更加符合情境的回答。
  2. **请求 AI 回复**：调用 `chat_stream(messages)` 获取 AI 回复结果。由于`chat_stream`已封装好流式处理和 JSON 解析，这里直接得到结构化的回复`ai_response`，其包含字段：`reply`（回复文本）, `emotion`（新情绪）, `status`（新状态）, `favor`（好感度变化）。
  3. **提取回复内容和新状态**：从返回结果中取出 `reply_text`（AI回复文本）、`new_emotion`、`new_status`以及`favor_delta`。并打印调试信息，显示模型最终决定的回复文本、情绪、状态和好感度变化值。
  4. **流式输出回复**：首先将完整回复文本按照语义或段落**拆分为多个块**（段落)。调用 `split_reply_into_blocks(reply_text)` 完成此功能，该函数会依据换行和句子完结符等将长回复分割成数个短块。随后对每个块依次处理：

     * **创建气泡**：在界面线程中先添加一个空的 NPC 回复气泡作为占位（调用 `chat_frame.start_stream_reply("npc")`)。这样一个空粉色气泡会出现在聊天框中，准备填充文本。
     * **逐字符输出**：对块内的文本逐字遍历，累积成`sentence`字符串。每当`sentence`构成一句完整的话（通过`is_sentence_end`判断末尾有句号、问号等**或**长度达到30字符）时，就将该`sentence`通过 `safe_append_text(chat_frame, sentence)` 附加到气泡标签上。这里`safe_append_text`内部实际调用的是`chat_frame.stream_append(text)`，确保线程安全地更新UI文本。然后根据输出长度`len(temp)`调用`time.sleep(len/10)`稍作延迟，模拟输入停顿，以更加真实。
     * 块中的文本处理完后，如果还有未输出的残留字符（sentence不为空），也一并追加输出。随后调用 `chat_frame.finalize_stream_reply()` 结束该气泡的流式输出。该方法负责清理流式状态，例如如果气泡内容最终为空则移除气泡等。
     * 然后继续处理下一块文本，以此方式每块文本将依次以新的气泡呈现，使长回复分段显示，避免单条消息过长。
  5. **更新状态和历史**：在全部回复文本输出完成后，将整条回复添加到历史记录列表 `history` 中，作为一条`role="assistant"`的记录。然后将 `state.emotion` 更新为 `new_emotion`，`state.status` 更新为 `new_status`，`state.favor` 增加 `favor_delta`。通过这些更新，游戏状态反映出这一轮对话后女主角的心情变化和好感度变化。
  6. **场景切换检测**：调用 `state.check_scene_transition()` 检查是否达到场景切换条件。如果检查后发现进入了最终场景“wedding”，则在聊天窗口添加该场景的 preset 系统旁白，用以告知玩家结局（如婚礼场景描述）。并将 `state.is_finished` 标记为 True。
  7. **保存进度**：调用 `save_history(history)` 保存更新后的历史记录到文件，调用 `state.save()` 保存更新后的游戏状态。这样即使程序中途退出，也不会丢失当前进度。
  8. **更新UI状态栏**：如果提供了 `update_status_callback` 回调函数，则通过 `chat_frame.after(0, ...)` 异步调用该函数。通常这个回调是主窗口的状态栏更新方法（Window\.update\_status），会读取当前 `state` 对象并刷新好感度、情绪、状态的显示。

执行完这些步骤后，AI 的回复文本已经完整显示在界面上，对应的情绪状态也更新展示，历史和状态文件也保存妥当。整个流程在后台线程完成，主线程的 GUI 依然响应良好，实现了流畅的对话体验。

#### controller/helpers.py（[跳转到源码](#source-helpers-py)）

**作用**：提供控制器相关的辅助函数。

* **`is_sentence_end(text: str) -> bool`** – 判断一段文本是否构成完整句子/语义段落。判定规则：

  1. 文本末尾包含句号、叹号、问号或换行符之一，则认为是一个句子的结束。
  2. 文本长度超过30字也可认为需要断句（防止长句）。
  3. 文本以“）”结尾（通常表示表情或动作的括号已闭合）也视为一句完成。

  满足以上任一条件即返回 True，否则 False。该函数用于流式输出时判断何时将累积的字符输出为一段，以确保断句自然。

#### controller/stream\_utils.py（[跳转到源码](#source-stream-utils-py)）

**作用**：提供流式输出过程中的实用函数。

* **`split_reply_into_blocks(text: str) -> list`** – 将完整回复文本按段落或语义拆分为多个块。实现：

  * 先按换行将文本分割为若干行，去除空白行。
  * 遍历每一行，将行内容累加到 `current` 字符串。如果发现该行本身已经构成完整语义（满足 `is_sentence_end`）或长度超过20字，就将当前累计的内容作为一个块 (`block`) 加入结果列表，然后重置 `current`。
  * 循环结束后，如`current`非空，则也作为最后一个块加入。

  返回的块列表用于控制每个气泡的内容范围，使输出以段落为单位更清晰。

* **`safe_append_text(chat_frame, text: str)`** – 安全地将文本追加到聊天界面的流式气泡中。由于 Tkinter 需要在主线程操作 UI，本函数实际上不直接调用，在代码中总是通过`chat_frame.after(0, lambda: safe_append_text(...))`方式使用，以确保在主线程执行。这也是为何其实现仅简单调用了`chat_frame.stream_append(text)`：真正的线程隔离由`after`来保证。

### GUI 模块 {#gui-module}

GUI 模块负责图形界面的构建，包括主窗口、聊天显示区域、输入区和控制面板等。所有界面相关的类均继承自 Tkinter 对应组件类，封装了界面元素和交互逻辑。

#### gui/window\.py（[跳转到源码](#source-window-py)）

**作用**：定义主窗口类 **Window**，继承自 `tk.Tk`。它负责初始化应用界面各部分，并协调控制器与界面组件的交互。

* **初始化** (`Window.__init__`) – 调用父类构造创建 Tk 窗口，并设置窗口属性：

  * 设置窗口标题为“校园恋爱模拟器”；设定窗口初始大小480x640像素，并允许用户自由调整窗口大小。
  * 创建聊天显示区域：实例化 `ChatFrame(self)` 作为窗口的聊天内容框架，并通过 `.pack(fill=BOTH, expand=True)`填充窗口主要空间。
  * 创建输入区域：实例化 `InputFrame(self, self.on_send)` 作为输入框，传入发送回调函数为当前 Window 的 `on_send` 方法。然后 `.pack(fill=X)` 将其放置在下方。这里将主窗口的发送处理函数引用传给输入框，确保用户点击发送按钮或按回车时调用Window\.on\_send。
  * 初始化控制器：创建 `ChatController(self.chat_frame, update_status_callback=self.update_status)` 实例赋给 `self.ctrl`。这样控制器可以通过持有的 `chat_frame` 引用来操作聊天界面，同时指定状态更新回调为当前 Window 的 `update_status` 方法，方便稍后更新状态栏。
  * 创建状态控制面板：调用 `build_control_panel(self)` 函数生成状态显示和按钮区域，将返回的控件字典赋给 `self.control_panel`。控制面板包括好感度、情绪、状态的 Label，以及“重新开始”和“关闭游戏”按钮，其事件分别绑定到 Window\.on\_restart 和 Window\.quit。该面板放置于窗口底部，用于显示实时状态和提供控制按钮。
  * 加载历史记录：调用 `load_history_if_any(self.ctrl, self.chat_frame)`，返回历史消息列表赋给 `self.history`。该函数会将历史消息逐条添加到聊天界面，并在其末尾插入一条分隔提示“———— 以上为历史记录 ————”。如果没有历史则返回空列表。
  * 启动开场白：使用 `self.after(100, lambda: start_intro_if_needed(self.ctrl, self.chat_frame, self.history))` 设定一个在窗口启动100毫秒后执行的任务。此任务会调用 `start_intro_if_needed` 来决定是否显示场景介绍旁白。实现逻辑如下：

    * 若 `history` 为空（首次对话），直接获取当前场景的预设旁白文本并通过控制器的 `push_system` 添加到界面（例如初始场景intro会有固定的旁白开场）。
    * 若存在历史记录（非首次启动），则异步启动一个线程调用 `generate_scene_intro(...)` 生成基于当前状态的场景提示语，并通过控制器 `push_system` 插入界面。这样确保在加载历史的情况下也能衔接出合适的旁白，引导继续对话。
  * 调用 `self.update_status()` 初始化状态栏显示。通常首次启动时好感度0、情绪“平静”、状态“放空”，该方法会读取当前控制器的状态对象并设置状态栏标签的文本。

* **`on_send(self, text: str)`** – 发送消息事件处理函数。当用户点击发送按钮或按下回车键时，InputFrame调用此回调，将输入文本传入：

  * 内部直接调用控制器的 `self.ctrl.on_user_input(text)` 方法，将用户输入交由 ChatController 处理。这样主窗口本身并不处理消息逻辑，而是委托控制器管理。但通过这个回调连接，GUI 和控制器建立了联系。

* **`update_status(self)`** – 刷新状态栏显示。读取控制器当前状态 `state = self.ctrl.state`，将状态栏的好感度标签文本设置为`"好感度: {favor}"`，情绪标签设置为`"情绪: {emotion}"`，状态标签设置为`"状态: {status}"`。最后调用 `debug_print` 输出调试信息，方便在日志中跟踪状态变化。控制器每次AI回复后通过回调触发此方法，确保UI状态显示与模型状态同步。

* **`on_restart(self)`** – 实现“重新开始”按钮功能。当用户点击“重新开始”：

  1. 调用 `reset_history()` 清空历史记录文件。
  2. 调用 `self.ctrl.state.reset()` 将内存中的游戏状态恢复初始，并清空状态保存文件。
  3. 利用 `os.execl` 重启当前 Python 程序。具体做法是获取当前 Python 可执行文件路径和脚本参数，然后执行自身。相当于重新启动了 ChatSim 应用，使之从头开始运行。这样可以清理所有内存中的旧数据，并自动进入新的会话。

#### gui/window\_init.py（[跳转到源码](#source-window-init-py)）

**作用**：提供窗口初始化过程中的辅助逻辑，主要包括历史加载和初始旁白处理。

* **`load_history_if_any(ctrl, chat_frame) -> list`** – 将历史记录加载到界面。参数为控制器和聊天框。

  * 调用 `model.history.load_history()` 获取历史消息列表。如列表为空则直接返回空列表。
  * 如果有历史消息，则打印调试信息并逐条遍历：将每条消息的角色`role`取出，如果角色是`"assistant"`则替换为`"npc"`（界面中NPC用于标识AI）。然后调用 `chat_frame.add_message(role, content)` 将消息添加到聊天窗口。这样用户之前的对话（包括用户消息和AI回复）都会按照当时的角色颜色重新显示出来。
  * 在所有历史消息添加完之后，插入一条系统消息分隔线。内容为“———— 以上为历史记录 ————”，用于提示用户上方是旧对话记录，新对话将在此分隔线下开始。
  * 返回加载的历史列表，以供后续逻辑使用。

* **`start_intro_if_needed(ctrl, chat_frame, history)`** – 根据是否有历史，决定并插入适当的开场旁白。参数为控制器、聊天框和已加载的历史列表。

  * 如果 `history` 列表为空（说明这是一次新的会话，没有往期对话），则认为需要插入初始旁白。通过 `get_prompt(ctrl.state.current_scene)` 获取当前场景的预设旁白文本（如场景 intro 通常有预定义的开场白）。取得文本后，调用 `ctrl.push_system(preset)` 将旁白作为系统消息添加到聊天界面。同时该消息也会加入历史列表中。
  * 如果 `history` 非空（存在往期对话），则表示这是一次载入历史后的继续对话。此时不使用预设旁白，而是**异步生成**场景提示。定义内部函数 `generate()` 来调用 `generate_scene_intro(current_scene, emotion, status, history)` 生成旁白。该函数利用当前场景名、女主角当前情绪和状态以及完整历史进行计算，返回一句场景描述（如“此时，你们正漫步在校园的小径上……”等）。生成结果赋给 `intro`，然后通过 `ctrl.push_system(intro)` 添加到界面。最后，以守护线程方式启动 `threading.Thread(target=generate)` 来执行这一生成过程，避免主线程等待。

通过上述逻辑，无论是新对话还是续接对话，用户都会在开始时看到适当的场景描述，有利于代入剧情。特别是在继续对话时采用AI生成，可以总结前情或描述当前状态，使衔接更加自然。

#### gui/chat\_frame.py（[跳转到源码](#source-chat-frame-py)）

**作用**：定义聊天显示区域类 **ChatFrame**，继承自 `tk.Frame`。它容纳聊天对话内容，包括滚动显示的对话气泡列表。

* **初始化** (`ChatFrame.__init__`) – 创建一个带滚动功能的画布来显示聊天内容：

  * 建立 `tk.Canvas` 作为主要显示区域，背景为白色，关闭边框高亮。在 Canvas 上创建一个内嵌的 Frame (`inner_frame`)，用于承载实际的消息组件。通过 `create_window` 将此 Frame 放置在 Canvas 原点，锚点为西北。
  * 添加垂直滚动条 `Scrollbar`，绑定 Canvas 的`yview`。并设置 Canvas 的滚动命令，使滚动条随内容移动而更新。
  * 使用 `.pack()`将 Canvas 放左侧扩展填充，Scrollbar 放右侧填充。
  * 设置字体：创建 Tkinter 字体 `tkFont.Font(family="微软雅黑", size=10)` 供对话气泡使用。
  * 创建 **ChatBubbleManager** 实例 `self.bubble_mgr = ChatBubbleManager(self.inner_frame, self.font)`。这个辅助管理器负责在给定父容器（inner\_frame）中创建对话气泡控件。
  * 绑定事件：当 `inner_frame`尺寸变化时调用 `_on_frame_configure` 动态更新 Canvas 滚动区域；当 Canvas 大小改变时调用 `_on_canvas_resize` 调整内部 Frame 宽度以适应。
  * 处理鼠标滚轮：根据操作系统分别绑定不同的滚轮事件（Windows/Darwin用`<MouseWheel>`，其他用`<Button-4/5>`）以实现滚动。
  * 初始化流式输出相关的属性：`stream_role = None`（当前正在流式输出的消息角色），`stream_label = None`（当前流式输出使用的 Label 控件），`stream_text = ""`（当前已输出的文本内容）。
* **内部方法**：

  * `_on_frame_configure` – 在聊天内容 Frame 大小变化时（添加新消息等），更新 Canvas 的滚动区域(scrollregion)为内容大小。
  * `_on_canvas_resize` – 在外部 Canvas 尺寸变化时，设置内部窗口宽度为新宽度，使内容宽度自适应窗口。
  * `_on_mousewheel` – 将鼠标滚轮事件转换为 Canvas 滚动行为。在 Windows/macOS上`event.delta`有值，可按其正负滚动units，对Linux则分别绑定Button4/5事件直接滚动。
  * `scroll_to_bottom()` – 滚动条跳至底部。在添加新消息后调用，保证最新消息可见。
* **消息操作方法**：

  * `add_message(role: str, text: str)` – 添加一条**静态消息气泡**。调用 `self.bubble_mgr.create_bubble(role, text)` 创建对应角色和内容的气泡控件并添加到界面。然后调用`scroll_to_bottom()`确保滚动条在最新位置。`role`参数通常为 `"user"`、`"npc"` 或 `"system"`，ChatBubbleManager 会根据角色设置不同背景颜色和对齐方式。
  * `start_stream_reply(role: str)` – 开始一个**流式输出**回复。通常在AI开始回复时调用。功能：

    * 打印调试信息指示开始流式回复。
    * 设置 `self.stream_role = role`，记录当前输出的角色（一般为"npc"）。
    * 调用 `self.bubble_mgr.start_stream_bubble(role)` 创建一个初始内容为空的气泡 Label，赋给 `self.stream_label`。对于role="npc"，这个Label背景为粉色，左对齐，但文本暂时为空。这样一个空的对话框已经显示在界面上。
    * 重置 `self.stream_text = ""` 清空临时文本缓存，并调用`scroll_to_bottom()`以滚动到底部准备显示。
  * `stream_append(text_chunk: str)` – 追加一段文本到当前流式气泡。当AI回复的一个小段就绪时由`safe_append_text`调用此方法：

    * 若当前没有流式Label（例如流式输出刚开始，此值可能为None），则重新调用 `start_stream_bubble` 创建。一般情形下在调用本方法前应已调用过`start_stream_reply`，所以通常`self.stream_label`已有值。
    * 将传入的文本块累加到 `self.stream_text`。
    * 更新 Label 文本：`self.stream_label.config(text=self.stream_text)`，并调用 `update_idletasks()`刷新UI。这样新追加的文字立即呈现在界面上。
    * 再次调用`scroll_to_bottom()`保证窗口自动滚动。
  * `finalize_stream_reply()` – 结束流式输出，收尾处理气泡。AI回复完成后由控制器线程调用：

    * 如果存在 `self.stream_label`（当前有正在输出的气泡）：

      * 若 Label 的文本内容全是空白而 `self.stream_text`有实质内容，则调用`config`设置 Label 文本为完整的`self.stream_text.strip()`。这种情况通常是由于某些字符可能未及时渲染，这里强制同步一次。
      * **清除空气泡**：如果 `self.stream_text`本身也是空的（说明AI最终什么也没输出，例如 fallback了空回复），则打印调试信息“移除空气泡”，并销毁该 Label 控件。避免界面遗留一个空白气泡占位。
      * 将 `self.stream_label`置 None，表示当前无流式会话。
    * 最后再次滚动到底部。此函数确保每次AI回复结束时界面状态清理干净，为下一次回复做好准备。

ChatFrame 封装的这些方法由控制器在适当时机调用。例如 ChatController 在收到新AI回复时先调用`start_stream_reply("npc")`创建气泡，然后每当有部分文本就绪就调用`stream_append`追加字符，最终调用`finalize_stream_reply`结束回复。如果用户滚动窗口或窗口大小改变，ChatFrame也会自动调整显示，保证体验良好。

#### gui/chat\_bubble.py（[跳转到源码](#source-chat-bubble-py)）

**作用**：提供 **ChatBubbleManager** 类，用于统一创建聊天气泡控件。

* **初始化**：`ChatBubbleManager(parent, font)` 保存父容器（聊天内容 Frame）引用和字体对象。所有气泡将作为 `parent` 的子元素创建，并使用指定字体。
* **`create_bubble(role: str, text: str)`** – 创建一个静态聊天气泡并添加到界面。

  * 根据角色选择气泡背景颜色：系统消息灰色（#f0f0f0），用户消息蓝色（#cce5ff），NPC(助手)消息粉色（#ffcce5），默认灰白。
  * 确定对齐方式：NPC和系统消息左对齐（anchor="w"），用户消息右对齐（anchor="e"）。据此设置容器放置在左侧还是右侧。
  * 创建外部 Frame 容器，用白色背景（与聊天背景一致）并在垂直方向有少许`pady`间距。
  * 创建 Label 控件作为气泡，父容器为上述 Frame。设置文本为传入内容，背景色为选定颜色，字体为指定字体，文本左对齐，anchor设为西（"w"），并设置`wraplength=320`以在约320px处自动换行，内部左右`padx=10`、上下`pady=6`提供内边距。
  * 将 Label 使用 `.pack()`布局到 Frame 中：如果是左对齐消息则`side="left", anchor="w"`；右对齐则`side="right", anchor="e"`，并在左右留出 10px 外边距。
  * 将外部 Frame 使用 `.pack()`放入父容器：anchor设置为与文本方向一致（左/右），水平填充（fill="x"）以占满宽度，并在垂直方向`pady=2`增加间距。
  * 函数不返回值。调用此函数即可在界面添加一条完整的聊天消息气泡。
* **`start_stream_bubble(role: str) -> tk.Label`** – 创建一个用于流式输出的空气泡，并返回其 Label 引用。

  * 只处理 NPC 等左对齐的情况：背景颜色目前仅对`"npc"`角色指定为粉色，其它角色默认为灰。因为项目中用户输入不需要流式效果。
  * 创建类似上方的外部 Frame 和 Label，但 Label 初始文本设为空字符串，其他属性相同。
  * Label 的 `pack`固定为left/west对齐（因仅用于NPC）。Frame 的`pack` anchor 也设"w"，保证气泡出现在左侧。
  * 返回创建的 Label 对象，以便 ChatFrame 持有并动态更新其文本。

ChatBubbleManager 将创建气泡的代码与布局封装起来，便于 ChatFrame 调用。通过统一管理背景色和对齐方式，保证不同角色消息的显示风格一致。同时通过提供`start_stream_bubble`接口，使流式消息的创建与静态消息分开处理。

#### gui/input\_frame.py（[跳转到源码](#source-input-frame-py)）

**作用**：定义输入区域组件 **InputFrame**，继承自 `tk.Frame`。包含文本输入框和发送按钮。

* **初始化** (`InputFrame.__init__`) – 在给定父容器下创建输入框和按钮：

  * 新建一个单行文本输入框 `tk.Entry` 并 `pack(side=LEFT, fill=X, expand=True)` 占据 Frame 大部分宽度，用于输入聊天内容。
  * 绑定事件：将 Entry 的`<Return>`（回车键）事件绑定到 `self.on_send` 方法。这样用户在文本框中按下回车即可发送消息。
  * 创建一个 Tk 按钮，文本为“发送”，命令绑定到 `self.on_send` 方法，然后 `pack(side=RIGHT)` 将按钮置于右侧。
  * 保存传入的回调函数 `callback`（通常是 Window\.on\_send）到 `self.callback`。
* **`on_send()`** – 处理发送按钮点击或回车事件。执行流程：

  * 获取输入框内容并去掉首尾空白 `.strip()`。
  * 如果文本非空，则调用保存的回调函数 `self.callback(text)` 将文本传出给主窗口处理（最终会到 ChatController）。
  * 无论是否发送，最后都调用 `self.entry.delete(0, END)` 清空输入框内容，为下一次输入做好准备。

InputFrame 将用户输入与主程序逻辑解耦：它自身不处理文本，只负责将用户操作转发。这样 Window 可以通过将自身的 on\_send 方法传入，实现对用户输入的统一管理。同时提供回车快捷发送，让用户体验更加流畅。

#### gui/control\_panel.py（[跳转到源码](#source-control-panel-py)）

**作用**：提供状态显示和控制按钮的面板构造函数。

* **`build_control_panel(window) -> dict`** – 构建一个包含状态标签和控制按钮的面板，并返回控件引用。`window` 参数是主窗口对象，需要实现`on_restart`和`quit`方法供按钮调用。

  * 创建一个 Frame 作为底板，背景浅灰（#f0f0f0）以区分于聊天区域，并适当设置`pady`使内容居中。使用`frame.pack(fill=X)`将其填充窗口宽度。
  * 创建 **好感度**、**情绪**、**状态** 三个 Label，分别作为静态文本前缀+默认值显示。例如好感度标签初始文本“好感度: 0”，宽度12字符左对齐；情绪和状态标签初始为“情绪: 平静”、“状态: 放空”，各宽度14字符左对齐。这样长度接近，布局整齐。
  * 创建 **重新开始** 按钮，文本“重新开始”，点击命令绑定到 `window.on_restart`；创建 **关闭游戏** 按钮，文本“关闭游戏”，命令绑定 `window.quit` 以退出应用。
  * 使用 `.pack()`布局：三个标签依次靠左排列（side=LEFT），按钮靠右排列（side=RIGHT），并设置一些`padx`间距。最终左右两侧分别为标签组和按钮组，中间留有空隙。
  * 将创建的 Frame 和各组件以字典形式返回，键包括 `"frame"`（面板Frame）、`"aff"`（好感度Label）、`"emo"`（情绪Label）、`"stat"`（状态Label）。主窗口将保存这个字典用于日后更新标签文本。

**控制面板**提供了对当前游戏状态的可视化和基本控制：通过标签直观展示当前好感度数值和AI情绪状态，通过按钮允许用户重开游戏或退出程序。其布局简洁明了，与聊天区域隔开，提升了应用的易用性。

#### utils/debug\_tools.py（[跳转到源码](#source-debug-tools-py)）

**作用**：提供调试日志打印工具。

* **`debug_print(*args, **kwargs)`** – 封装内置`print`函数的变体。只有当全局 `DEBUG_MODE` 为 True 时才会实际调用`print`输出；否则不做任何事。这允许在代码中大量使用`debug_print`记录调试信息，而无需担心在正常模式下干扰用户界面或性能。输出格式上，`debug_print`会在打印内容前自动加上`[DEBUG]`标识，以便区分调试信息。

项目各模块广泛使用了`debug_print`来记录重要事件（如API调用、文件操作、状态变更等），方便开发者在调试模式下跟踪程序运行流程。例如AI每次回复的内容、情绪变化、文件保存成功与否等都有对应的调试输出。在发布或正常使用时将`DEBUG_MODE`置False即可静默这些信息。

## 编码规范

ChatSim 项目遵循明确的编码规范，以提高代码一致性和可读性：

* **总体风格**：遵循 *Google Python 风格指南* 和 PEP 8 约定，代码排版清晰，适当添加空行分隔逻辑段落，每行不超过80字符，缩进使用4个空格。
* **命名约定**：模块、包、文件夹名一律小写，用下划线分隔（如`chat_controller.py`，`scene_generator.py`）；类名使用**帕斯卡命名**（驼峰式，首字母大写，如`ChatController`）；函数和变量名使用**蛇形命名**（全部小写，下划线分隔单词，如`reset_history`、`is_autogen`）。常量使用全大写加下划线（如`DEBUG_MODE`, `HISTORY_PATH`）。
* **注释与文档**：每个模块开头、类和函数定义都编写了**docstring**字符串，用简体中文详细说明其作用、参数和返回值等。注释风格上，采用**Google风格docstring**格式，在描述后使用“Args:”“Returns:”等标签分段说明参数和返回。行内注释适当穿插在代码中解释关键步骤或易迷惑逻辑。所有注释力求**简洁明了**，直接说明意图。
* **代码组织**：按职责划分模块，保证单一模块内逻辑内聚。Controller不直接执行UI操作，而是通过传入的回调来更新界面；GUI组件不直接调用模型，而是触发事件由Controller处理。这种松耦合使得代码更易维护和扩展。
* **目录结构**：按照MVC分层组织代码文件，各目录下文件进一步细分功能。例如model下将游戏状态相关逻辑放入`game_state`子包中，清晰区分状态类、加载器和场景跳转逻辑。建议在增加新功能时也按此风格放入对应层级，而非堆积在单一文件中。
* **错误处理**：代码中使用了大量 `try-except` 来保证健壮性，例如文件读取、写入和API请求都有异常捕获。在 except 中通常会调用 `debug_print` 输出错误信息，便于调试但不中断程序主流程。开发者在新增代码时，也应遵循这个策略处理可能的异常情况。
* **可拓展性**：通过配置文件和数据驱动设计提高可拓展性。比如情绪和状态选项、场景及阈值都在`config.py`集中定义，后续若要添加新的情绪类型或场景剧情，仅需修改配置而无需改动代码逻辑。推荐在实现新功能时，也尽量将易变的数据提取到配置或常量处。

总之，编码风格力求**语义清晰、风格统一**。无论是命名还是注释，都以提高代码自解释性为目的，使开发者无需翻阅大量文档也能理解代码意图。同时借助类型注解和良好模块划分，让IDE和读者都能方便地导航项目结构。

## 构建与运行

ChatSim 为纯 Python 项目，无需特殊构建步骤，但为了顺利运行，需要做好环境准备并正确配置 API 密钥：

1. **环境要求**：确保安装了 Python 3.7+。建议使用虚拟环境来隔离依赖。创建并激活虚拟环境示例：

   ```bash
   python3 -m venv .venv
   source .venv/bin/activate  # Windows 下使用 .venv\Scripts\activate
   ```
2. **获取代码**：从 GitHub 仓库克隆项目源码：

   ```bash
   git clone https://github.com/Baakarshan/chat_sim.git
   cd chat_sim
   ```
3. **安装依赖**：项目所需的第三方库列在`requirements.txt`中。使用 pip 安装：

   ```bash
   pip install -r requirements.txt
   ```

   主要依赖包括：`openai`（与模型交互）, `tkinter`（通常随Python内置，无需另装）等。如果安装过程中出现网络问题，可考虑切换pip源或手动安装相应包。
4. **配置 API Key**：在运行前，请配置您的 OpenAI API 密钥：

   * 方法一：编辑项目根目录下的 **`config.py`** 文件，将其中的`API_KEY`值替换为您的密钥字符串。**切记不要**将含有私人 API 密钥的文件上传到公共仓库。
   * 方法二：不修改源码，改用环境变量。在运行程序前，将您的 API Key 赋给环境变量**ARK\_API\_KEY**（或 config.py 中期望的键名）。例如：

     * Linux/macOS: `export ARK_API_KEY="sk-你的API密钥"`
     * Windows CMD: `set ARK_API_KEY=sk-你的API密钥`
     * Windows PowerShell: `$env:ARK_API_KEY="sk-你的API密钥"`
   * \*可选：\*如果使用非官方代理或服务，还需相应修改`BASE_URL`或设置`ENDPOINT_ID`等，以匹配目标服务的接口格式。
5. **运行应用**：在项目目录下执行：

   ```bash
   python main.py
   ```

   程序将启动桌面GUI窗口。如果一切配置正确，您会看到主界面，并可在下方输入框中与AI开始对话。首次运行会自动出现开场旁白，之后您输入内容按“发送”或回车，AI 将回应。
6. **使用说明**：对话过程中，界面上方状态栏会动态更新女主角对玩家的好感度数值以及她的情绪和状态。当好感度累计达到某些阈值时，剧情场景会自动推进并可能生成新的场景旁白提示。您可随时点击“重新开始”按钮以清空进度并重置对话（当前窗口会重启），或点击“关闭游戏”退出程序。
7. **开发调试**：如需查看详细日志，可在`config.py`中将 `DEBUG_MODE` 设为 True。然后在终端运行程序，将会输出模型调用、场景切换、文件读写等调试信息，有助于排查问题。

按照以上步骤，您应能成功运行 ChatSim 并体验其完整功能。如果在安装或运行过程中遇到错误，请检查 Python 和依赖库版本是否符合要求，以及 API Key 是否正确配置。同时欢迎通过 GitHub 提交 issue 反馈使用中遇到的问题或建议改进之处。祝您使用愉快，期待您的 PR 为本项目添砖加瓦！

---

## 附录：主要源码

以下为 ChatSim 项目各主要源文件的代码片段，供参考对照说明。点击各文件名可返回正文相关解释部分。

**main.py** <a id="source-main-py"></a>

```python
# main.py
# coding: utf-8
""" 程序主入口。 遵循 Google Python 风格指南，增加详细中文注释。 """
from gui.window import Window  # 导入主窗口类

def main() -> None:
    """ 主函数，启动应用程序。 """
    app = Window()      # 创建窗口实例
    app.mainloop()      # 启动 Tkinter 主循环，进入消息处理

if __name__ == "__main__":
    main()  # 仅当直接运行本文件时才执行主函数
```

**config.py** <a id="source-config-py"></a>

```python
# config.py
# coding: utf-8
""" 全局配置文件。 遵循 Google Python 风格指南，增加详细中文注释。 """
import os  # 导入操作系统接口模块

# ========== OPENAI 接口配置 ==========
API_KEY: str      = os.getenv("ARK_API_KEY", "0696b289-62f9-46dc-812c-1c5e2d3bfbef")  # API 密钥，优先从环境变量读取
ENDPOINT_ID: str  = os.getenv("ENDPOINT_ID", "doubao-seed-1-6-250615")              # 接口端点 ID
BASE_URL: str     = "https://ark.cn-beijing.volces.com/api/v3/"                     # API 基础 URL

# ========== 路径配置 ==========
HISTORY_PATH: str = "data/history.json"  # 聊天历史文件路径
STATE_PATH: str   = "data/state.json"    # 游戏状态文件路径

# ========== 游戏场景配置 ==========
SCENES: dict = {
    "intro": {
        "trigger": 10,                   # 触发分数
        "next": ["library"],             # 下一个场景
        "preset": "旁白：你在校园里第一次遇到她...",  # 预设旁白
        "autogen": False                # 是否自动生成
    },
    "library": {
        "trigger": 30,
        "next": ["wedding"],
        "autogen": True
    },
    "wedding": {
        "trigger": 80,
        "next": [],
        "preset": "旁白：多年后，你们在樱花树下举行了婚礼。",
        "autogen": False
    }
}

# ========== 候选情绪（固定两个字） ==========
EMOTIONS: list = [ "开心", "冷漠", "害羞", "生气", "难过", "惊讶", "平静" ]

# ========== 候选状态（固定两个字） ==========
STATUSES: list = [ "放空", "紧张", "期待", "学习", "烦恼", "思考", "回忆" ]

# ========== 控制项 ==========
DEBUG_MODE: bool = True  # 是否开启调试模式
```

**model/history.py** <a id="source-history-py"></a>

```python
# model/history.py
# coding: utf-8
""" 历史记录管理模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
import json  # 导入 JSON 序列化模块
import os    # 导入操作系统模块
from config import HISTORY_PATH  # 导入历史文件路径
from utils.debug_tools import debug_print  # 导入调试打印

def load_history() -> list:
    """ 从文件加载历史记录。
    Returns:
        list: 聊天历史消息列表。
    """
    if not os.path.exists(HISTORY_PATH):
        return []
    try:
        with open(HISTORY_PATH, 'r', encoding='utf-8') as f:
            content = f.read().strip()
            if not content:
                return []
            return json.loads(content)
    except Exception as e:
        debug_print("加载历史记录失败：", e)
        return []

def save_history(history: list) -> None:
    """ 保存当前历史记录。
    Args:
        history: 聊天历史消息列表。
    """
    try:
        with open(HISTORY_PATH, 'w', encoding='utf-8') as f:
            json.dump(history, f, ensure_ascii=False, indent=2)
        debug_print("历史记录保存成功")
    except Exception as e:
        debug_print("保存历史记录失败：", e)

def reset_history() -> None:
    """ 清空历史记录文件。 """
    try:
        with open(HISTORY_PATH, 'w', encoding='utf-8') as f:
            f.write("[]")  # 写入空列表，清空历史
        debug_print("历史记录已清空")
    except Exception as e:
        debug_print("重置历史记录失败：", e)
```

**model/game\_state/**init**.py** (GameState 类) <a id="source-gamestate"></a>

```python
# model/game_state/__init__.py
# coding: utf-8
""" 游戏状态主类与接口。 遵循 Google Python 风格指南，增加详细中文注释。 """
from .loader import load_state, save_state, reset_state_file  # 导入状态加载与保存
from .transition import check_scene_transition               # 导入场景跳转逻辑

class GameState:
    """ 游戏状态类，管理当前场景、好感度、情绪等。 """
    def __init__(self):
        self.current_scene = "intro"      # 当前场景
        self.favor         = 0           # 好感度
        self.triggered     = set()       # 已触发场景集合
        self.is_finished   = False       # 是否已结束
        self.emotion       = "平静"      # 当前情绪（固定两个字）
        self.status        = "放空"      # 当前状态（固定两个字）

    def to_dict(self) -> dict:
        """ 转换为字典，便于序列化。
        Returns:
            dict: 状态字典。
        """
        return {
            "current_scene": self.current_scene,
            "favor":         self.favor,
            "triggered":     list(self.triggered),
            "is_finished":   self.is_finished,
            "emotion":       self.emotion,
            "status":        self.status
        }

    def save(self) -> None:
        """ 保存当前状态到本地。 """
        save_state(self)

    def reset(self) -> None:
        """ 重置状态并清除存档。 """
        reset_state_file()
        self.__init__()

    def check_scene_transition(self) -> None:
        """ 判断是否达到跳转条件。 """
        check_scene_transition(self)

    @classmethod
    def load(cls):
        """ 从本地加载游戏状态。
        Returns:
            GameState: 加载后的状态对象。
        """
        return load_state(cls)
```

**model/game\_state/loader.py** <a id="source-loader-py"></a>

```python
# model/game_state/loader.py
# coding: utf-8
""" 游戏状态加载与保存模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
import json     # 导入 JSON 序列化模块
import os       # 导入操作系统模块
from config import STATE_PATH         # 导入状态文件路径
from utils.debug_tools import debug_print  # 导入调试打印

def load_state(GameStateClass):
    """ 从文件中加载状态，如果失败则返回初始状态。
    Args:
        GameStateClass: 游戏状态类。
    Returns:
        GameStateClass: 加载后的状态对象。
    """
    if not os.path.exists(STATE_PATH):
        debug_print("未找到状态文件，使用默认初始状态")
        return GameStateClass()
    try:
        with open(STATE_PATH, 'r', encoding='utf-8-sig') as f:
            content = f.read().strip()
            if not content:
                debug_print("状态文件为空，使用初始状态")
                return GameStateClass()
            data = json.loads(content)
            obj = GameStateClass()
            obj.current_scene = data.get("current_scene", "intro")
            obj.favor         = data.get("favor", 0)
            obj.triggered     = set(data.get("triggered", []))
            obj.is_finished   = data.get("is_finished", False)
            obj.emotion       = data.get("emotion", "平静")
            obj.status        = data.get("status", "放空")
            return obj
    except Exception as e:
        debug_print("加载状态失败，错误信息：", e)
        return GameStateClass()

def save_state(state_obj) -> None:
    """ 保存状态到文件。
    Args:
        state_obj: 游戏状态对象。
    """
    try:
        with open(STATE_PATH, 'w', encoding='utf-8-sig') as f:
            json.dump(state_obj.to_dict(), f, ensure_ascii=False, indent=2)
        debug_print("状态保存成功")
    except Exception as e:
        debug_print("保存状态失败：", e)

def reset_state_file() -> None:
    """ 清空状态文件。 """
    try:
        with open(STATE_PATH, 'w', encoding='utf-8') as f:
            f.write("")
        debug_print("状态文件已重置为空")
    except Exception as e:
        debug_print("重置状态文件失败：", e)
```

**model/game\_state/transition.py** <a id="source-transition-py"></a>

```python
# model/game_state/transition.py
# coding: utf-8
""" 场景跳转逻辑模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
from model.scene import get_trigger_threshold, get_next_scene, is_autogen  # 导入场景相关方法
from model.scene_generator import generate_scene_intro                     # 导入场景 intro 生成
from utils.debug_tools import debug_print  # 导入调试打印

def check_scene_transition(state) -> None:
    """ 判断当前好感度是否满足场景跳转条件，如满足则切换场景并添加旁白。
    Args:
        state: 游戏状态对象。
    Returns:
        None
    """
    current = state.current_scene
    trigger = get_trigger_threshold(current)
    if state.favor >= trigger and current not in state.triggered:
        debug_print(f"好感度已达阈值（{state.favor} >= {trigger}），触发场景跳转")
        state.triggered.add(current)
        next_scene = get_next_scene(current)
        if not next_scene:
            debug_print("无下一个场景")
            return
        state.current_scene = next_scene
        if is_autogen(next_scene):
            debug_print("新场景支持自动旁白，等待异步生成")
        else:
            debug_print("新场景使用 preset 旁白")
```

**model/chatbot\_api.py** <a id="source-chatbot-api-py"></a>

```python
# model/chatbot_api.py
# coding: utf-8
""" 大模型 API 封装模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
from openai import OpenAI  # 导入 OpenAI SDK
from config import API_KEY, ENDPOINT_ID, BASE_URL  # 导入 API 配置
from model.chat_fallback import get_default_reply  # 导入默认回复
from utils.debug_tools import debug_print  # 导入调试打印
import threading  # 导入线程库
import queue      # 导入队列库
import time       # 导入时间库
import json       # 导入 JSON 序列化

client = OpenAI(
    api_key=API_KEY,
    base_url=BASE_URL,
)

def chat_stream(messages: list) -> dict:
    """ 主对话流式生成函数：逐块返回模型输出；如超时自动 fallback。
    Args:
        messages: 聊天上下文消息列表。
    Returns:
        dict: 结构化回复（reply, emotion, status, favor）。
    """
    result_queue = queue.Queue()    # 结果队列
    finished = threading.Event()    # 完成事件

    # 添加结构化提示 system prompt（确保总是开头）
    system_instruction = {
        "role": "system",
        "content": (
            "你是校园恋爱模拟器中的女主角，接下来你将扮演女主角，回复玩家说的话。"
            "请你以以下格式回复一个合法 JSON 对象，内容必须包含以下字段：\n"
            "- reply：你想说的话，1~3 句短句即可，建议加括号动作（如“（轻笑）真的吗？”）\n"
            "- emotion：当前情绪，必须是以下之一：开心、生气、冷漠、害羞、惊讶、难过、平静\n"
            "- status：当前状态，必须是以下之一：放空、思考、期待、紧张、学习\n"
            "- favor：整数，表示你对玩家的好感度变化（例如 2，-1）\n"
            "⚠️ 你必须只输出 JSON 对象，不加任何注释、解释或自然语言。"
        )
    }
    messages = [system_instruction] + messages[-20:]  # 限制长度

    def run_stream():
        try:
            debug_print("开始调用大模型（流式模式）...")
            for chunk in client.chat.completions.create(
                model=ENDPOINT_ID,
                messages=messages,
                stream=True,
            ):
                delta = chunk.choices[0].delta
                if hasattr(delta, "content") and delta.content:
                    result_queue.put(delta.content)
            finished.set()
        except Exception as e:
            debug_print("模型流异常：", e)
            finished.set()

    threading.Thread(target=run_stream, daemon=True).start()

    full_reply = ""
    start_time = time.time()
    while not finished.is_set() or not result_queue.empty():
        try:
            piece = result_queue.get(timeout=1)
            full_reply += piece
        except queue.Empty:
            if time.time() - start_time > 15:
                debug_print("等待模型超时，使用 fallback")
                break

    # 尝试解析结构化 JSON（reply/emotion/status/favor）
    try:
        response = json.loads(full_reply)
        if all(k in response for k in ("reply", "emotion", "status", "favor")):
            return response
    except Exception as e:
        debug_print("结构化解析失败，fallback 使用默认")

    return {
        "reply": full_reply.strip() or get_default_reply(),
        "emotion": "平静",
        "status": "放空",
        "favor": 0
    }

def chat_once(messages: list) -> str:
    """ 单轮调用，用于生成场景 intro 提示。
    Args:
        messages: 聊天上下文消息列表。
    Returns:
        str: 单句文本回复。
    """
    try:
        debug_print("调用 chat_once 获取单句文本")
        response = client.chat.completions.create(
            model=ENDPOINT_ID,
            messages=messages,
            stream=False,
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        debug_print("chat_once 调用失败：", e)
        return get_default_reply()
```

**model/chat\_fallback.py** <a id="source-chat-fallback-py"></a>

```python
# model/chat_fallback.py
# coding: utf-8
""" 模型兜底与旁白引导模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
def get_default_reply() -> str:
    """ 当模型长时间不响应时，返回默认文本。
    Returns:
        str: 默认回复文本。
    """
    return "……（她没回应你，好像有点冷淡）"

def build_scene_prompt(scene_name: str) -> str:
    """ 构造旁白生成引导词，用于 AI 输出一句简洁的场景提示语。
    示例输出：
        “午后，图书馆一角，阳光透过玻璃。”
        “黄昏，操场边，她独自坐在长椅。”
    Args:
        scene_name: 场景名称。
    Returns:
        str: 旁白引导词。
    """
    return (
        f"你是游戏旁白系统，请基于当前场景“{scene_name}”生成简洁场景描述，包含时间、地点、天气，"
        "如：“傍晚，教学楼门口，天空飘着细雨。”。请模仿这种口吻，每次只返回一句话。"
    )
```

**model/scene.py** <a id="source-scene-py"></a>

```python
# model/scene.py
# coding: utf-8
""" 场景信息与逻辑模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
from config import SCENES  # 导入场景配置
from model.scene_generator import generate_scene_intro  # 导入场景 intro 生成

def get_prompt(scene_id: str) -> str:
    """ 获取指定场景的固定 preset 旁白（若存在）。
    Args:
        scene_id: 场景 ID。
    Returns:
        str: 旁白文本。
    """
    scene = SCENES.get(scene_id)
    if scene and scene.get("preset"):
        return scene["preset"]
    return ""

def is_autogen(scene_id: str) -> bool:
    """ 判断该场景是否允许自动生成旁白。
    Args:
        scene_id: 场景 ID。
    Returns:
        bool: 是否自动生成。
    """
    scene = SCENES.get(scene_id)
    return scene.get("autogen", False)

def get_trigger_threshold(scene_id: str) -> int:
    """ 获取该场景的好感触发阈值。
    Args:
        scene_id: 场景 ID。
    Returns:
        int: 好感度阈值。
    """
    scene = SCENES.get(scene_id)
    return scene.get("trigger", 0)

def get_next_scene(scene_id: str) -> str:
    """ 获取该场景的下一步（默认取第一个）。
    Args:
        scene_id: 场景 ID。
    Returns:
        str: 下一个场景 ID。
    """
    scene = SCENES.get(scene_id)
    next_list = scene.get("next", [])
    return next_list[0] if next_list else ""

def should_enter_scene(current_scene: str, favor: int) -> bool:
    """ 判断是否触发进入下一个场景。
    Args:
        current_scene: 当前场景 ID。
        favor: 当前好感度。
    Returns:
        bool: 是否满足进入条件。
    """
    threshold = get_trigger_threshold(current_scene)
    return favor >= threshold
```

**model/scene\_generator.py** <a id="source-scene-generator-py"></a>

```python
# model/scene_generator.py
# coding: utf-8
""" 场景提示语生成模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
from model.chatbot_api import chat_once  # 导入单轮对话接口
from utils.debug_tools import debug_print  # 导入调试打印

def generate_scene_intro(current_scene: str, emotion: str, status: str, history: list) -> str:
    """ 调用大模型生成一条新的场景提示语（除首次外）。
    Args:
        current_scene: 当前场景名，如 "intro"。
        emotion: 当前情绪，如 "冷漠"。
        status: 当前状态，如 "学习"。
        history: 历史对话列表。
    Returns:
        str: 场景提示语（建议 10~25 字）。
    """
    system_prompt = f"""
你是校园恋爱模拟器中的旁白生成器。
请根据以下要素生成一条简洁的场景描写（10~25字）：
- 当前场景：“{current_scene}”
- 女主情绪：“{emotion}”
- 女主状态：“{status}”
- 玩家刚刚说的话：“{get_last_user_input(history)}”
请直接返回一句中文短句，不加注释。
""".strip()
    messages = [{"role": "system", "content": system_prompt}]
    result = chat_once(messages)
    debug_print("AI生成场景提示：", result)
    return result.strip()

def get_last_user_input(history: list) -> str:
    """ 返回最近一条用户输入。
    Args:
        history: 聊天历史列表。
    Returns:
        str: 最近一条用户输入内容。
    """
    for msg in reversed(history):
        if msg["role"] == "user":
            return msg["content"]
    return "（无）"
```

**controller/chat\_controller.py** <a id="source-chat-controller-py"></a>

```python
# controller/chat_controller.py
# coding: utf-8
""" 聊天控制器模块。 遵循 Google Python 风格指南，增加类型注解和详细中文注释。 """
import threading  # 导入线程库，用于异步处理
from typing import Callable, Optional  # 类型注解
from model.history import load_history, save_history  # 导入历史记录相关方法
from model.game_state import GameState  # 导入游戏状态类
from controller.stream_handler import handle_stream_response  # 导入流式响应处理函数
from utils.debug_tools import debug_print  # 导入调试打印工具

class ChatController:
    """ 聊天控制器，负责管理聊天逻辑、状态与历史。 """
    def __init__(self, chat_frame, update_status_callback: Optional[Callable] = None, auto_intro: bool = True):
        """ 初始化聊天控制器。
        Args:
            chat_frame: 聊天界面框架对象。
            update_status_callback: 状态更新回调函数，可选。
            auto_intro: 是否自动显示开场白。
        """
        self.chat_frame = chat_frame                # 聊天界面框架
        self.update_status_callback = update_status_callback  # 状态更新回调
        self.state = GameState.load()               # 加载游戏状态
        self.history = load_history()               # 加载历史记录
        self._first_prompt_shown = False            # 是否已显示首次提示
        # ✅ 删除自动生成旁白的逻辑，让 window_init 控制 intro 显示

    def push_system(self, text: str) -> None:
        """ 添加系统气泡到聊天框。
        Args:
            text: 系统消息文本。
        """
        self.chat_frame.after(0, lambda: self.chat_frame.add_message("system", text))  # UI 线程安全地添加系统消息
        self.history.append({"role": "system", "content": text})  # 记录到历史

    def on_user_input(self, text: str) -> None:
        """ 处理用户输入，记录并触发 AI 回复。
        Args:
            text: 用户输入文本。
        """
        debug_print("玩家输入：", text)  # 调试输出玩家输入
        self.chat_frame.after(0, lambda: self.chat_frame.add_message("user", text))  # UI 线程安全地添加用户消息
        self.history.append({"role": "user", "content": text})  # 记录到历史
        # 启动异步 AI 回复线程，传入 UI 刷新回调
        threading.Thread(
            target=handle_stream_response,  # 目标函数为流式响应处理
            args=(self.chat_frame, self.state, self.history, self.update_status_callback),  # 传递参数
            daemon=True                     # 设置为守护线程
        ).start()
```

**controller/stream\_handler.py** <a id="source-stream-handler-py"></a>

```python
# controller/stream_handler.py
# coding: utf-8
""" 流式响应处理模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
import time        # 导入时间模块，用于延时
import threading   # 导入线程模块（如需异步）
from model.chatbot_api import chat_stream       # 导入 AI 聊天流接口
from model.scene import get_prompt              # 导入场景提示获取方法
from controller.helpers import is_sentence_end  # 导入句子结束判断
from model.history import save_history          # 导入历史保存方法
from utils.debug_tools import debug_print       # 导入调试打印
from controller.stream_utils import split_reply_into_blocks, safe_append_text  # 导入分段与安全追加

def handle_stream_response(chat_frame, state, history, update_status_callback=None):
    """ 处理 AI 的流式回复，并更新 UI、历史和状态。
    Args:
        chat_frame: 聊天界面框架。
        state: 游戏状态对象。
        history: 聊天历史列表。
        update_status_callback: 状态更新回调函数，可选。
    """
    # 构建上下文消息（含系统提示）
    emotion_prompt = {"role": "system", "content": f"当前情绪：{state.emotion}，状态：{state.status}"}
    messages = [emotion_prompt] + history  # 合成消息上下文

    # 获取 AI 回复（结构化返回）
    ai_response = chat_stream(messages)  # 请求 AI 聊天接口
    reply_text   = ai_response.get("reply", "")          # 获取回复文本
    new_emotion  = ai_response.get("emotion", state.emotion)  # 获取新情绪
    new_status   = ai_response.get("status", state.status)    # 获取新状态
    favor_delta  = ai_response.get("favor", 0)           # 获取好感度变化

    debug_print("最终回复：", reply_text)        # 输出 AI 回复
    debug_print("AI判断情绪：", new_emotion)
    debug_print("AI判断状态：", new_status)
    debug_print("AI判定好感度变化：", favor_delta)

    # 分段显示回复内容（逐字流式输出）
    reply_blocks = split_reply_into_blocks(reply_text)  # 分段
    for block in reply_blocks:
        if not block.strip():
            continue  # 跳过空段
        debug_print("流式生成一段气泡：", block)
        chat_frame.after(0, lambda: chat_frame.start_stream_reply("npc"))  # 启动 NPC 气泡
        sentence = ""  # 当前句子缓存
        for char in block:
            sentence += char  # 累加字符
            if is_sentence_end(sentence) or len(sentence) >= 30:
                temp = sentence.strip()
                if temp:
                    chat_frame.after(0, lambda s=temp: safe_append_text(chat_frame, s))  # 安全追加文本
                time.sleep(len(temp) / 10)  # 按长度延时
                sentence = ""
        if sentence.strip():
            temp = sentence.strip()
            chat_frame.after(0, lambda s=temp: safe_append_text(chat_frame, s))
        chat_frame.after(0, chat_frame.finalize_stream_reply)  # 结束气泡

    # 更新本地状态
    history.append({"role": "assistant", "content": reply_text})  # 记录 AI 回复
    state.emotion = new_emotion     # 更新情绪
    state.status  = new_status      # 更新状态
    state.favor  += favor_delta     # 更新好感度

    # 检查是否进入终场景
    state.check_scene_transition()  # 检查场景切换
    if state.current_scene == "wedding":
        chat_frame.after(0, lambda: chat_frame.add_message("system", get_prompt("wedding")))  # 终场景旁白
        state.is_finished = True    # 标记结束

    # 保存历史与状态
    save_history(history)  # 保存历史
    state.save()           # 保存状态

    # ✅ 显式调用 UI 更新函数
    if update_status_callback:
        chat_frame.after(0, update_status_callback)  # UI 线程安全调用
```

**controller/helpers.py** <a id="source-helpers-py"></a>

```python
# controller/helpers.py
# coding: utf-8
""" 辅助函数模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
def is_sentence_end(text: str) -> bool:
    """ 判断一段文字是否已构成完整回复（用于气泡分段）。
    满足以下任一条件即可判定为“结束”：
    - 末尾有句号、叹号、问号（。！？）或换行符
    - 或长度超过 30 字
    - 或以 '）' 结尾（常见动作括号）
    Args:
        text: 输入的文本字符串。
    Returns:
        bool: 是否为完整回复。
    """
    # 检查是否包含句号、叹号、问号或换行符
    if any(p in text for p in "。！？\n"):
        return True
    # 检查长度是否超过 30 字
    if len(text) > 30:
        return True
    # 检查是否以 '）' 结尾
    if text.endswith("）"):
        return True
    return False
```

**controller/stream\_utils.py** <a id="source-stream-utils-py"></a>

```python
# controller/stream_utils.py
# coding: utf-8
""" 流式输出工具模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
from controller.helpers import is_sentence_end  # 导入句子结束判断函数

def split_reply_into_blocks(text: str) -> list:
    """
    将完整回复按段落或语义拆分为多个小段，每段后续作为一个气泡独立显示。
    Args:
        text: 完整回复文本。
    Returns:
        list: 拆分后的小段列表。
    """
    lines = [line.strip() for line in text.strip().split("\n") if line.strip()]  # 按行去除空白
    blocks = []      # 存储分段结果
    current = ""     # 当前段落缓存
    for line in lines:
        current += line + " "  # 累加行内容
        # 若该行已构成完整语义或长度较长，则分段
        if is_sentence_end(line.strip()) or len(line.strip()) > 20:
            blocks.append(current.strip())
            current = ""
    if current.strip():
        blocks.append(current.strip())  # 处理最后一段
    return blocks

def safe_append_text(chat_frame, text: str) -> None:
    """ 用于 thread-safe 更新 Tkinter 气泡内容。
    注意：这个函数会在 lambda 中被调用。
    Args:
        chat_frame: 聊天界面框架。
        text: 追加的文本内容。
    """
    chat_frame.stream_append(text)
```

**gui/window\.py** <a id="source-window-py"></a>

```python
# gui/window.py
# coding: utf-8
""" 主窗口模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
import tkinter as tk         # 导入 Tkinter 库
from controller.chat_controller import ChatController   # 聊天控制器
from gui.chat_frame import ChatFrame       # 聊天界面
from gui.input_frame import InputFrame     # 输入框
from gui.control_panel import build_control_panel   # 控制面板
from gui.window_init import load_history_if_any, start_intro_if_needed  # 初始化逻辑
from model.history import reset_history    # 重置历史
from utils.debug_tools import debug_print  # 调试打印
import sys   # 系统操作
import os    # 操作系统接口

class Window(tk.Tk):
    """ 主窗口类，负责整体界面与主流程。 """
    def __init__(self):
        super().__init__()
        self.title("校园恋爱模拟器")     # 设置窗口标题
        self.geometry("480x640")         # 设置窗口大小
        self.resizable(True, True)       # 允许缩放

        self.chat_frame = ChatFrame(self)           # 聊天内容区
        self.chat_frame.pack(fill=tk.BOTH, expand=True)
        self.input_frame = InputFrame(self, self.on_send)  # 输入区
        self.input_frame.pack(fill=tk.X)  # ✅ 显式传入 UI 刷新函数

        self.ctrl = ChatController(self.chat_frame, update_status_callback=self.update_status)
        self.control_panel = build_control_panel(self)   # 状态栏与按钮

        self.history = load_history_if_any(self.ctrl, self.chat_frame)  # 加载历史
        self.after(100, lambda: start_intro_if_needed(self.ctrl, self.chat_frame, self.history))  # 场景 intro
        self.update_status()  # 初始化状态栏

    def on_send(self, text: str) -> None:
        """ 处理发送按钮事件。
        Args:
            text: 用户输入文本。
        """
        self.ctrl.on_user_input(text)

    def update_status(self) -> None:
        """ 同步状态栏显示：好感度、情绪、状态。 """
        state = self.ctrl.state
        self.control_panel["aff"].config(text=f"好感度: {state.favor}")
        self.control_panel["emo"].config(text=f"情绪: {state.emotion}")
        self.control_panel["stat"].config(text=f"状态: {state.status}")
        debug_print("已更新状态栏：", state.favor, state.emotion, state.status)

    def on_restart(self) -> None:
        """ 重启游戏（保留当前窗口）。 """
        reset_history()
        self.ctrl.state.reset()
        python = sys.executable
        os.execl(python, python, *sys.argv)
```

**gui/window\_init.py** <a id="source-window-init-py"></a>

```python
# gui/window_init.py
# coding: utf-8
""" 窗口初始化相关逻辑。 遵循 Google Python 风格指南，增加详细中文注释。 """
from model.history import load_history  # 导入历史加载
from model.scene import get_prompt      # 导入场景提示
from model.scene_generator import generate_scene_intro  # 导入场景 intro 生成
from utils.debug_tools import debug_print  # 导入调试打印
import threading  # 导入线程库

def load_history_if_any(ctrl, chat_frame):
    """ 加载历史记录到聊天界面。
    Args:
        ctrl: 聊天控制器。
        chat_frame: 聊天界面。
    Returns:
        list: 历史消息列表。
    """
    history = load_history()  # 加载历史
    if not history:
        return []
    debug_print("成功加载历史记录")
    debug_print("加载历史记录条数：", len(history))
    for msg in history:
        role = msg["role"]
        if role == "assistant":
            role = "npc"  # assistant 统一为 npc
        chat_frame.add_message(role, msg["content"])
    # ✅ 添加历史记录标线
    chat_frame.add_message("system", "———— 以上为历史记录 ————")
    return history

def start_intro_if_needed(ctrl, chat_frame, history):
    """ 启动时判断是否需要补充旁白。
    - 无历史：插入默认 preset
    - 有历史：异步生成 AI 场景提示，避免卡顿
    Args:
        ctrl: 聊天控制器。
        chat_frame: 聊天界面。
        history: 历史消息列表。
    """
    if not history:
        debug_print("首次启动，注入初始旁白")
        preset = get_prompt(ctrl.state.current_scene)  # 获取当前场景 preset
        ctrl.push_system(preset)
        return
    debug_print("历史存在，异步生成 intro 场景提示")
    def generate():
        intro = generate_scene_intro(
            current_scene=ctrl.state.current_scene,
            emotion=ctrl.state.emotion,
            status=ctrl.state.status,
            history=history
        )
        ctrl.push_system(intro)
    threading.Thread(target=generate, daemon=True).start()  # 异步生成 intro
```

**gui/chat\_frame.py** <a id="source-chat-frame-py"></a>

```python
# gui/chat_frame.py
# coding: utf-8
""" 聊天主界面框架。 遵循 Google Python 风格指南，增加详细中文注释。 """
import tkinter as tk            # 导入 Tkinter 库
from tkinter import font as tkFont  # 导入字体模块
from .chat_bubble import ChatBubbleManager  # 导入气泡管理器
from utils.debug_tools import debug_print   # 导入调试打印
import platform  # 导入平台判断

class ChatFrame(tk.Frame):
    """ 聊天主界面，包含滚动、气泡等。 """
    def __init__(self, master):
        super().__init__(master)
        self.canvas = tk.Canvas(self, bg="white", highlightthickness=0)  # 聊天内容画布
        self.scrollbar = tk.Scrollbar(self, orient="vertical", command=self.canvas.yview)  # 垂直滚动条
        self.inner_frame = tk.Frame(self.canvas, bg="white")  # 内部内容框架
        self.inner_window = self.canvas.create_window((0, 0), window=self.inner_frame, anchor="nw")  # 嵌入内容

        self.canvas.configure(yscrollcommand=self.scrollbar.set)
        self.canvas.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        self.scrollbar.pack(side=tk.RIGHT, fill=tk.Y)

        self.font = tkFont.Font(family="微软雅黑", size=10)  # 聊天气泡字体
        self.bubble_mgr = ChatBubbleManager(self.inner_frame, self.font)  # 气泡管理器

        self.inner_frame.bind("<Configure>", self._on_frame_configure)  # 内容变化时更新滚动区域
        self.canvas.bind("<Configure>", self._on_canvas_resize)  # 画布大小变化时调整内容宽度

        # 鼠标滚轮支持（跨平台）
        system = platform.system()
        if system in ("Windows", "Darwin"):
            self.canvas.bind_all("<MouseWheel>", self._on_mousewheel)
        else:
            self.canvas.bind_all("<Button-4>", lambda e: self.canvas.yview_scroll(-1, "units"))
            self.canvas.bind_all("<Button-5>", lambda e: self.canvas.yview_scroll(1, "units"))

        self.stream_role = None   # 当前流式角色
        self.stream_label = None  # 当前流式标签
        self.stream_text = ""     # 当前流式文本

    def _on_frame_configure(self, event):
        """ 内容区域变化时，更新滚动区域。 """
        self.canvas.configure(scrollregion=self.canvas.bbox("all"))

    def _on_canvas_resize(self, event):
        """ 画布大小变化时，调整内容宽度。 """
        self.canvas.itemconfig(self.inner_window, width=event.width)

    def _on_mousewheel(self, event):
        """ 鼠标滚轮滚动事件。 """
        self.canvas.yview_scroll(-1 * (event.delta // 120), "units")

    def scroll_to_bottom(self):
        """ 滚动到底部。 """
        self.canvas.update_idletasks()
        self.canvas.yview_moveto(1.0)

    def add_message(self, role: str, text: str) -> None:
        """ 添加静态聊天气泡。
        Args:
            role: 消息角色。
            text: 消息内容。
        """
        debug_print(f"添加静态气泡 [{role}]：{text}")
        self.bubble_mgr.create_bubble(role, text)
        self.scroll_to_bottom()

    def start_stream_reply(self, role: str) -> None:
        """ 开始流式生成回复气泡。
        Args:
            role: 消息角色。
        """
        debug_print("开始流式生成回复气泡")
        self.stream_role = role
        self.stream_label = self.bubble_mgr.start_stream_bubble(role)
        self.stream_text = ""
        self.scroll_to_bottom()

    def stream_append(self, text_chunk: str) -> None:
        """ 追加流式文本到当前气泡。
        Args:
            text_chunk: 新增文本。
        """
        if self.stream_label is None:
            self.stream_label = self.bubble_mgr.start_stream_bubble(self.stream_role)
        self.stream_text += text_chunk
        self.stream_label.config(text=self.stream_text)
        self.stream_label.update_idletasks()
        self.scroll_to_bottom()

    def finalize_stream_reply(self) -> None:
        """ 结束流式回复，处理空气泡或补全内容。 """
        if self.stream_label:
            if not self.stream_label.cget("text").strip() and self.stream_text.strip():
                self.stream_label.config(text=self.stream_text.strip())
            elif not self.stream_text.strip():
                debug_print("移除空气泡")
                self.stream_label.destroy()
            self.stream_label = None
        self.scroll_to_bottom()
```

**gui/chat\_bubble.py** <a id="source-chat-bubble-py"></a>

```python
# gui/chat_bubble.py
# coding: utf-8
""" 聊天气泡管理模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
import tkinter as tk  # 导入 Tkinter 库

class ChatBubbleManager:
    """ 聊天气泡管理器，负责在界面上创建和管理聊天气泡。 """
    def __init__(self, parent, font):
        """ 初始化气泡管理器。
        Args:
            parent: 父级 Tkinter 容器。
            font: 使用的字体。
        """
        self.parent = parent  # 聊天气泡的父容器
        self.font = font      # 聊天气泡字体

    def create_bubble(self, role: str, text: str) -> None:
        """ 创建一个静态聊天气泡。
        Args:
            role: 消息角色（system/user/npc）。
            text: 显示的文本内容。
        """
        bg_color = {"system": "#f0f0f0", "user": "#cce5ff", "npc": "#ffcce5"}.get(role, "#eeeeee")  # 背景色
        align = "w" if role in ["npc", "system"] else "e"  # 对齐方式
        side = "left" if align == "w" else "right"         # 侧边
        outer = tk.Frame(self.parent, bg="white", pady=2)  # 外部容器
        label = tk.Label(
            outer, text=text, bg=bg_color, font=self.font,
            justify="left", anchor="w", wraplength=320, padx=10, pady=6
        )
        label.pack(side=side, anchor=align, padx=10)       # 放置标签
        outer.pack(anchor=align, fill="x", padx=5, pady=2)  # 放置外部容器

    def start_stream_bubble(self, role: str):
        """ 创建一个用于流式输出的气泡（初始内容为空）。
        Args:
            role: 消息角色（npc等）。
        Returns:
            label: 可动态更新内容的 Label。
        """
        bg_color = {"npc": "#ffcce5"}.get(role, "#eeeeee")  # 背景色
        outer = tk.Frame(self.parent, bg="white", pady=2)   # 外部容器
        label = tk.Label(
            outer, text="", bg=bg_color, font=self.font,
            justify="left", anchor="w", wraplength=320, padx=10, pady=6
        )
        label.pack(side="left", anchor="w", padx=10)        # 放置标签
        outer.pack(anchor="w", fill="x", padx=5, pady=2)    # 放置外部容器
        return label  # 返回可动态更新的标签
```

**gui/input\_frame.py** <a id="source-input-frame-py"></a>

```python
# gui/input_frame.py
# coding: utf-8
""" 输入框模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
import tkinter as tk  # 导入 Tkinter 库

class InputFrame(tk.Frame):
    """ 聊天输入框组件。 """
    def __init__(self, master, callback):
        """ 初始化输入框。
        Args:
            master: 父级容器。
            callback: 发送消息回调函数。
        """
        super().__init__(master)
        self.entry = tk.Entry(self)        # 文本输入框
        self.entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        self.entry.bind("<Return>", lambda e: self.on_send())  # 回车发送
        tk.Button(self, text="发送", command=self.on_send).pack(side=tk.RIGHT)
        self.callback = callback           # 回调函数

    def on_send(self) -> None:
        """ 发送消息事件处理。 """
        text = self.entry.get().strip()    # 获取输入内容
        if text:
            self.callback(text)           # 调用回调
        self.entry.delete(0, tk.END)      # 清空输入框
```

**gui/control\_panel.py** <a id="source-control-panel-py"></a>

```python
# gui/control_panel.py
# coding: utf-8
""" 控制面板构建模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
import tkinter as tk  # 导入 Tkinter 库

def build_control_panel(window):
    """ 创建控制面板：状态标签 + 按钮。
    Args:
        window: 主窗口对象，需实现 on_restart 和 quit 方法。
    Returns:
        dict: 控件字典 {frame, aff, emo, stat}。
    """
    frame = tk.Frame(window, bg="#f0f0f0", pady=4)  # 外部面板
    frame.pack(fill=tk.X)
    aff_label  = tk.Label(frame, text="好感度: 0",   width=12, anchor="w")  # 好感度标签
    emo_label  = tk.Label(frame, text="情绪: 平静", width=14, anchor="w")  # 情绪标签
    stat_label = tk.Label(frame, text="状态: 放空", width=14, anchor="w")  # 状态标签
    restart_btn = tk.Button(frame, text="重新开始", command=window.on_restart)  # 重新开始按钮
    quit_btn    = tk.Button(frame, text="关闭游戏", command=window.quit)       # 关闭游戏按钮

    aff_label.pack(side=tk.LEFT, padx=5)
    emo_label.pack(side=tk.LEFT, padx=5)
    stat_label.pack(side=tk.LEFT, padx=5)
    restart_btn.pack(side=tk.RIGHT, padx=5)
    quit_btn.pack(side=tk.RIGHT, padx=5)
    return {
        "frame": frame,   # 面板框架
        "aff": aff_label, # 好感度标签
        "emo": emo_label, # 情绪标签
        "stat": stat_label# 状态标签
    }
```

**utils/debug\_tools.py** <a id="source-debug-tools-py"></a>

```python
# utils/debug_tools.py
# coding: utf-8
""" 调试工具模块。 遵循 Google Python 风格指南，增加详细中文注释。 """
from config import DEBUG_MODE  # 导入调试模式开关

def debug_print(*args, **kwargs) -> None:
    """ 仅在开启调试模式时输出调试信息。
    Args:
        *args: 位置参数，传递给 print。
        **kwargs: 关键字参数，传递给 print。
    """
    if DEBUG_MODE:
        print("[DEBUG]", *args, **kwargs)
```
